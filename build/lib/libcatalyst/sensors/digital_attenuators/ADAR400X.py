import time

register_map = {
    0x00000000: 0x00,
    0x00000001: 0x00,
    0x00000003: 0x00,
    0x00000004: 0x00,
    0x00000005: 0x00,
    0x00000006: 0x00,
    0x00000008: 0x00,
    0x0000000A: 0x00,
    0x0000000B: 0x00,
    0x00000010: 0x00,
    0x00000011: 0x00,
    0x00000012: 0x00,
    0x00000013: 0x00,
    0x00000015: 0x00,
    0x00000016: 0x00,
    0x00000040: 0x00,
    0x00000041: 0x00,
    0x00000042: 0x00,
    0x00000043: 0x00,
    0x00000044: 0x00,
    0x00000045: 0x00,
    0x00000046: 0x00,
    0x00000050: 0x00,
    0x00000051: 0x00,
    0x00000052: 0x00,
    0x00000060: 0x00,
    0x00000061: 0x00,
    0x00000062: 0x00,
    0x00000063: 0x00,
    0x00000064: 0x00,
    0x00000065: 0x00,
    0x00000066: 0x00,
    0x00000067: 0x00,
    0x00000080: 0x00,
    0x00000081: 0x00,
    0x00000082: 0x00,
    0x00000083: 0x00,
    0x00000084: 0x00,
    0x00000085: 0x00,
    0x00000086: 0x00,
    0x00000087: 0x00,
    0x000000A0: 0x00,
    0x000000A1: 0x00,
    0x000000A2: 0x00,
    0x000000A3: 0x00,
    0x000000A4: 0x00,
    0x000000A5: 0x00,
    0x000000A6: 0x00,
    0x000000A7: 0x00,
    0x000000A8: 0x00,
    0x000000A9: 0x00,
    0x000000AA: 0x00,
    0x000000AB: 0x00,
    0x000000AC: 0x00,
    0x000000AD: 0x00,
    0x000000AE: 0x00,
    0x000000AF: 0x00,
    0x000000C0: 0x00,
    0x000000C1: 0x00,
    0x000000C2: 0x00,
    0x000000C3: 0x00,
    0x000000C4: 0x00,
    0x000000C5: 0x00,
    0x000000C6: 0x00,
    0x000000C7: 0x00,
    0x00000100: 0x00,
    0x00000101: 0x00,
    0x00000102: 0x00,
    0x00000103: 0x00,
    0x00000104: 0x00,
    0x00000105: 0x00,
    0x00000106: 0x00,
    0x00000107: 0x00,
    0x00000130: 0x00,
    0x00000131: 0x00,
    0x00000132: 0x00,
    0x00000133: 0x00,
    0x00000134: 0x00,
    0x00000135: 0x00,
    0x00000136: 0x00,
    0x00000137: 0x00,
    0x00000138: 0x00,
    0x00000139: 0x00,
    0x0000013A: 0x00,
    0x0000013B: 0x00,
    0x0000013C: 0x00,
    0x0000013D: 0x00,
    0x0000013E: 0x00,
    0x0000013F: 0x00,
    0x00000140: 0x00,
    0x00000141: 0x00,
    0x00000142: 0x00,
    0x00000143: 0x00,
    0x00000144: 0x00,
    0x00000145: 0x00,
    0x00000146: 0x00,
    0x00000147: 0x00,
    0x00000148: 0x00,
    0x00000149: 0x00,
    0x0000014A: 0x00,
    0x0000014B: 0x00,
    0x0000014C: 0x00,
    0x0000014D: 0x00,
    0x0000014E: 0x00,
    0x0000014F: 0x00,
    0x00000150: 0x00,
    0x00000151: 0x00,
    0x00000152: 0x00,
    0x00000153: 0x00,
    0x00000154: 0x00,
    0x00000155: 0x00,
    0x00000156: 0x00,
    0x00000157: 0x00,
    0x00000158: 0x00,
    0x00000159: 0x00,
    0x0000015A: 0x00,
    0x0000015B: 0x00,
    0x0000015C: 0x00,
    0x0000015D: 0x00,
    0x0000015E: 0x00,
    0x0000015F: 0x00,
    0x00000160: 0x00,
    0x00000161: 0x00,
    0x00000162: 0x00,
    0x00000163: 0x00,
    0x00000164: 0x00,
    0x00000165: 0x00,
    0x00000166: 0x00,
    0x00000167: 0x00,
    0x00000168: 0x00,
    0x00000169: 0x00,
    0x0000016A: 0x00,
    0x0000016B: 0x00,
    0x0000016C: 0x00,
    0x0000016D: 0x00,
    0x0000016E: 0x00,
    0x0000016F: 0x00,
    0x00000230: 0x00,
    0x00000231: 0x00,
    0x00000232: 0x00,
    0x00000233: 0x00,
    0x00000234: 0x00,
    0x00000235: 0x00,
    0x00000236: 0x00,
    0x00000237: 0x00,
    0x00000238: 0x00,
    0x00000239: 0x00,
    0x0000023A: 0x00,
    0x0000023B: 0x00,
    0x0000023C: 0x00,
    0x0000023D: 0x00,
    0x0000023E: 0x00,
    0x0000023F: 0x00,
    0x00000240: 0x00,
    0x00000241: 0x00,
    0x00000242: 0x00,
    0x00000243: 0x00,
    0x00000244: 0x00,
    0x00000245: 0x00,
    0x00000246: 0x00,
    0x00000247: 0x00,
    0x00000248: 0x00,
    0x00000249: 0x00,
    0x0000024A: 0x00,
    0x0000024B: 0x00,
    0x0000024C: 0x00,
    0x0000024D: 0x00,
    0x0000024E: 0x00,
    0x0000024F: 0x00,
    0x00000250: 0x00,
    0x00000251: 0x00,
    0x00000252: 0x00,
    0x00000253: 0x00,
    0x00000254: 0x00,
    0x00000255: 0x00,
    0x00000256: 0x00,
    0x00000257: 0x00,
    0x00000258: 0x00,
    0x00000259: 0x00,
    0x0000025A: 0x00,
    0x0000025B: 0x00,
    0x0000025C: 0x00,
    0x0000025D: 0x00,
    0x0000025E: 0x00,
    0x0000025F: 0x00,
    0x000002F0: 0x00,
    0x000002F1: 0x00,
    0x000002F2: 0x00,
    0x000002F3: 0x00,
    0x000002F4: 0x00,
    0x000002F5: 0x00,
    0x000002F6: 0x00,
    0x00000308: 0x00,
    0x00000309: 0x00,
    0x0000030A: 0x00,
    0x0000030B: 0x00,
    0x0000030C: 0x00,
    0x0000030D: 0x00,
    0x0000030E: 0x00,
    0x00000320: 0x00,
    0x00000321: 0x00,
    0x00000322: 0x00,
    0x00000323: 0x00,
    0x00000324: 0x00,
    0x00000325: 0x00,
    0x00000326: 0x00,
    0x00000340: 0x00,
    0x00000341: 0x00,
    0x00000342: 0x00,
    0x00000343: 0x00,
    0x00000344: 0x00,
    0x00000345: 0x00,
    0x00000346: 0x00,
    0x00000347: 0x00,
    0x00000350: 0x00,
    0x00000351: 0x00,
    0x00000352: 0x00,
    0x00000353: 0x00,
    0x00000360: 0x00,
    0x00000361: 0x00,
    0x00000368: 0x00,
    0x00000369: 0x00,
    0x00000371: 0x00,
    0x00000372: 0x00,
    0x00000373: 0x00,
    0x00000374: 0x00,
    0x00000375: 0x00,
    0x000003A0: 0x00,
    0x000003A1: 0x00,
    0x000003A2: 0x00,
    0x000003A3: 0x00,
    0x000003A4: 0x00,
    0x000003A5: 0x00,
    0x000003A6: 0x00,
    0x000003A7: 0x00,
    0x000003C0: 0x00,
    0x000003C1: 0x00,
    0x000003C2: 0x00,
    0x000003C3: 0x00,
    0x000003C8: 0x00,
    0x000003C9: 0x00,
    0x000003D0: 0x00,
    0x000003D1: 0x00,
    0x000003D2: 0x00,
    0x000003D3: 0x00,
    0x000003D4: 0x00,
    0x000003D5: 0x00,
    0x000003D6: 0x00,
    0x000003E8: 0x00,
    0x000003E9: 0x00,
    0x000003EC: 0x00,
}

class ADAR400X():
    def __init__(self, driver, cs, hardware_address):
        self.max_time_delay = 255
        self.num_bits = 32
        self.driver = driver
        self.cs = cs
        self.hardware_address = hardware_address
        self.register_map = {i: None for i in range(0x3ED)}  # Initialize register map
        self.TDmode = [0, 0, 0, 0]

        #self.setup()

    def setup(self):
        self._soft_reset()
        self._soft_reset()
        self._set_direct_control()

    def _soft_reset(self):
        addr = 0x000
        data = 0xBD
        spi_word = (addr << 8) | data
        self.driver.write_spi(self.cs, spi_word, self.num_bits)

    def _set_direct_control(self):
        addr = 0x011
        data = 0x00
        spi_word = (addr << 8) | data
        self.driver.write_spi(self.cs, spi_word, self.num_bits)

    def set_time_delay(self, channel, time_delay):
        if channel < 0 or channel > 3:
            raise ValueError("Channel must be between 0 and 3.")
        
        if time_delay < 0 or time_delay > self.max_time_delay:
            raise ValueError(f"Time delay must be between 0 and {self.max_time_delay}.")
        
        # Address mapping: 0x100 + 2 * channel
        addr = 0x100 + channel * 2
        spi_word = (addr << 8) | time_delay

        self.driver.write_spi(self.cs, spi_word, self.num_bits)
        self.register_map[addr] = time_delay
        self._update_TDmode()

        return spi_word

    def set_time_delay_all(self, time_delay):
        for channel in range(4):
            self.set_time_delay(channel, time_delay)

    def set_time_delay_spectrum(self, channel):
        for delay in range(0, 256, 13):
            self.set_time_delay(channel, delay)
            time.sleep(2)

    def load_file(self, filename):
        with open(filename, "r") as file:
            for line in file:
                # Split and validate fields
                fields = line.strip().split(",")
                if len(fields) < 2:
                    print(f"Skipping malformed line: {line.strip()}")
                    continue

                try:
                    # Parse address (24 bits) and data (8 bits) as hexadecimal
                    address, data = map(lambda x: int(x, 16), fields[:2])

                    # Ensure address and data fit within their respective ranges
                    if address > 0xFFFFFF:  # 24 bits for address
                        raise ValueError(f"Address {address:#X} exceeds 24-bit limit.")
                    if data > 0xFF:  # 8 bits for data
                        raise ValueError(f"Data {data:#X} exceeds 8-bit limit.")

                    # Construct the 32-bit SPI word: [24 bits of address | 8 bits of data]
                    spi_word = (address << 8) | data

                    # Write SPI word
                    self.driver.write_spi(self.cs, spi_word, 32)  # Send 32 bits
                    self.register_map[address] = data
                except ValueError as e:
                    print(f"Skipping line due to parsing or range error: {line.strip()}")
                    print(f"Error: {e}")


    def _update_TDmode(self):
        for i, addr in enumerate(range(0x100, 0x107, 2)):
            reg_value = self.register_map.get(addr)
            self.TDmode[i] = 0 if reg_value is None or reg_value <= 127 else 1

    def sleep_mode(self):
        self.load_file("./sleep.csv")
